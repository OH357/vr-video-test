<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>VR 360 iPhone Debug/Fix</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family: system-ui, sans-serif; }
    a-scene { width:100%; height:100%; }
    #ui { position: absolute; z-index: 1000; left: 12px; top: 12px; right: 12px; color: #fff; }
    #videoInline { width: 100%; max-height: 45vh; background:#000; }
    #enterVR, #bind { padding:10px 14px; border:0; border-radius:10px; background:#ff5500; color:#fff; margin-top:8px; }
    #log { white-space: pre-wrap; font-size: 12px; opacity:.85; margin-top:8px; }
  </style>
</head>
<body>
  <div id="ui">
    <div>Step 1: Tap ▶️ on the inline video. If it plays here, the URL/codec is OK.</div>
    <video id="videoInline" controls playsinline webkit-playsinline muted preload="metadata"></video>
    <div>
      <button id="bind" disabled>Step 2: Bind to 360 Sphere</button>
      <button id="enterVR" disabled>Step 3: Enter VR (split screen)</button>
    </div>
    <div id="log"></div>
  </div>

  <a-scene id="scene" renderer="antialias:true; xrCompatible:true" loading-screen="enabled:false" vr-mode-ui="enabled:true">
    <a-entity camera look-controls="magicWindowTrackingEnabled:true"></a-entity>
    <a-videosphere id="sphere" rotation="0 -90 0"></a-videosphere>
  </a-scene>

  <script>
    const VIDEO_URL = "https://dl.dropboxusercontent.com/scl/fi/utgpd1pjcu0up53r1ptr8/preview.mp4?rlkey=dqkeowyhp2voxe7wxkvbeo5ar&st=tvsj40te&raw=1";

    const logEl = document.getElementById('log');
    const scene = document.getElementById('scene');
    const sphere = document.getElementById('sphere');
    const video = document.getElementById('videoInline');
    const bindBtn = document.getElementById('bind');
    const enterVRBtn = document.getElementById('enterVR');

    function log(...args){ console.log(...args); logEl.textContent += args.join(' ') + "\n"; }

    // Set source only now (helps some iOS policies)
    video.crossOrigin = "anonymous"; // request CORS if server supports it
    video.src = VIDEO_URL;

    video.addEventListener('loadedmetadata', () => log('loadedmetadata:', video.videoWidth+'x'+video.videoHeight));
    video.addEventListener('canplay', () => log('canplay'));
    video.addEventListener('playing', () => { log('playing'); bindBtn.disabled = false; });
    video.addEventListener('error', () => log('video error code:', (video.error && video.error.code) || 'unknown'));

    async function ensureMotionPermission() {
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); log('Motion permission granted'); } catch(e){ log('Motion permission denied', e); }
      }
    }

    bindBtn.addEventListener('click', async () => {
      // Hide the UI after binding
      try {
        // IMPORTANT: attach the same <video> element to the sphere material
        sphere.setAttribute('material', { src: '#videoInline' });

        // If CORS is not allowed by Dropbox, WebGL will "taint" and sphere may remain black.
        // This proves a CORS/texture issue if inline video plays but sphere stays blank.
        log('Bound video to sphere material');
        enterVRBtn.disabled = false;

        // Optionally hide the inline player now (uncomment if you want)
        // document.getElementById('ui').style.display = 'none';
      } catch (e) {
        log('Bind error:', e);
      }
    });

    enterVRBtn.addEventListener('click', async () => {
      await ensureMotionPermission();
      try {
        // Make sure video is playing (iOS requires a gesture before .play)
        await video.play().catch(()=>{});
        await scene.enterVR();
        log('Requested enterVR');
      } catch (e) {
        log('enterVR error:', e);
        // Fallback: fullscreen so user can still pan around
        const fs = scene.requestFullscreen || scene.webkitRequestFullscreen || scene.msRequestFullscreen;
        try { fs && fs.call(scene); log('Entered fullscreen fallback'); } catch(_) {}
      }
    });
  </script>
</body>
</html>